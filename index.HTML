<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Dashboard Design Recife</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Chart.js para os gr√°ficos -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    :root {
      --bg: #0f172a;
      --bg-soft: #111827;
      --bg-card: #020617;
      --accent: #38bdf8;
      --accent-soft: rgba(56,189,248,0.15);
      --accent-strong: #0ea5e9;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --danger: #f97373;
      --border: #1f2937;
      --chip-bg: #111827;
      --chip-active-bg: #0f766e;
      --chip-active-border: #14b8a6;
      --scrollbar-thumb: #4b5563;
      --scrollbar-track: #111827;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 24px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top left, #1e293b 0, #020617 40%, #000 100%);
      color: var(--text);
    }

    h1, h2, h3, h4 {
      margin: 0;
      font-weight: 600;
    }

    .page {
      max-width: 1440px;
      margin: 0 auto 80px auto;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
      margin-bottom: 24px;
    }

    .title-block h1 {
      font-size: 28px;
      letter-spacing: 0.03em;
    }

    .title-block p {
      margin: 4px 0 0 0;
      font-size: 13px;
      color: var(--muted);
    }

    .tag-live {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(220,38,38,0.1);
      border: 1px solid rgba(248,113,113,0.65);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #fecaca;
    }

    .tag-live-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #ef4444;
      box-shadow: 0 0 0 4px rgba(248,113,113,0.3);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      60% { transform: scale(1.8); opacity: 0; }
      100% { transform: scale(1.8); opacity: 0; }
    }

    .header-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 8px;
    }

    .pill-row {
      display: inline-flex;
      background: rgba(15,23,42,0.9);
      border-radius: 999px;
      padding: 3px;
      border: 1px solid var(--border);
    }

    .pill {
      padding: 5px 14px;
      border-radius: 999px;
      font-size: 11px;
      color: var(--muted);
      cursor: pointer;
      border: none;
      background: transparent;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      transition: background 0.15s, color 0.15s;
    }

    .pill.active {
      background: var(--accent-soft);
      color: var(--accent-strong);
    }

    .pill + .pill {
      margin-left: 2px;
    }

    .last-update {
      font-size: 11px;
      color: var(--muted);
    }

    .filters-row {
      display: grid;
      grid-template-columns: minmax(0,2.4fr) minmax(0,2.4fr) minmax(0,2fr) minmax(0,2.2fr);
      gap: 12px;
      margin-bottom: 18px;
    }

    .filter-chip-group {
      background: rgba(15,23,42,0.9);
      border-radius: 14px;
      padding: 8px 10px;
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .filter-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .filter-label span {
      opacity: 0.85;
    }

.filter-scroll {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  max-height: 120px;   /* <-- aqui, aumentei de 72 para 120 */
  overflow-y: 120;
  overflow-x: hidden;
  padding-right: 2px;
  padding-bottom: 2px;
}

    .filter-scroll::-webkit-scrollbar {
      width: 5px;
    }
    .filter-scroll::-webkit-scrollbar-track {
      background: transparent;
    }
    .filter-scroll::-webkit-scrollbar-thumb {
      background: var(--scrollbar-thumb);
      border-radius: 999px;
    }

    .chip {
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 11px;
      border: 1px solid rgba(55,65,81,0.9);
      background: var(--chip-bg);
      color: var(--muted);
      cursor: pointer;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.15s, border-color 0.15s, color 0.15s, transform 0.1s;
    }

    .chip:hover {
      transform: translateY(-1px);
      border-color: var(--accent);
    }

    .chip.active {
      background: var(--chip-active-bg);
      border-color: var(--chip-active-border);
      color: #e0f2f1;
    }

    .chip-badge {
      font-size: 10px;
      padding: 1px 6px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      color: var(--muted);
    }

    .search-input-wrapper {
      position: relative;
      display: flex;
      align-items: center;
    }

    .search-input-wrapper input {
      width: 100%;
      padding: 8px 10px 8px 28px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #020617;
      color: var(--text);
      font-size: 12px;
      outline: none;
    }

    .search-input-wrapper input::placeholder {
      color: var(--muted);
    }

    .search-icon {
      position: absolute;
      left: 9px;
      font-size: 12px;
      color: var(--muted);
    }

    .search-stats {
      margin-top: 6px;
      font-size: 11px;
      color: var(--muted);
    }

    .search-last-row {
      margin-top: 6px;
    }

    .layout-grid {
      display: grid;
      grid-template-columns: minmax(0, 2.2fr) minmax(0, 1.8fr);
      gap: 14px;
      align-items: start;
    }

    .layout-grid + .layout-grid {
      margin-top: 14px;
    }

    .card {
      background: rgba(15,23,42,0.9);
      border-radius: 16px;
      padding: 12px 12px 10px 12px;
      border: 1px solid var(--border);
      box-shadow: 0 18px 40px rgba(0,0,0,0.55);
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .card-title {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
    }

    .card-subtitle {
      font-size: 11px;
      color: var(--muted);
    }

    .kpi-row {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr)); /* agora 5 KPIs */
      gap: 10px;
      margin-bottom: 12px;
    }

    .kpi-card {
      background: var(--bg-card);
      border-radius: 14px;
      padding: 10px 10px 8px;
      border: 1px solid #1f2937;
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .kpi-label {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.07em;
    }

    .kpi-value {
      font-size: 20px;
      font-weight: 600;
    }

    .kpi-foot {
      font-size: 10px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .pill-toggle {
      display: inline-flex;
      background: rgba(15,23,42,0.9);
      border-radius: 999px;
      padding: 2px;
      border: 1px solid var(--border);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .pill-toggle button {
      padding: 3px 7px;
      border-radius: 999px;
      background: transparent;
      border: none;
      color: var(--muted);
      cursor: pointer;
    }

    .pill-toggle button.active {
      background: var(--accent-soft);
      color: var(--accent-strong);
    }

    .chart-container {
      margin-top: 4px;
      position: relative;
      height: 210px;
    }

    .chart-container-tall {
      height: 260px;
    }

    .time-badges {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
    }

    .time-badge {
      background: var(--bg-card);
      border-radius: 12px;
      padding: 8px;
      border: 1px solid #1f2937;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 3px;
      transition: border-color 0.15s, background 0.15s, transform 0.08s;
    }

    .time-badge:hover {
      border-color: var(--accent);
      transform: translateY(-1px);
      background: radial-gradient(circle at top left, rgba(56,189,248,0.08), #020617 40%);
    }

    .time-badge-label {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.07em;
    }

    .time-badge-main {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
    }

    .time-badge-value {
      font-size: 16px;
      font-weight: 600;
    }

    .time-badge-foot {
      font-size: 10px;
      color: var(--muted);
    }

    .segment-danger {
      border-color: rgba(248,113,113,0.6);
      background: radial-gradient(circle at top left, rgba(248,113,113,0.12), #020617 40%);
    }

    .segment-danger:hover {
      border-color: #f87171;
      background: radial-gradient(circle at top left, rgba(248,113,113,0.2), #020617 40%);
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(15,23,42,0.85);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 50;
    }

    .modal-backdrop.show {
      display: flex;
    }

    .modal {
      width: min(920px, 95vw);
      max-height: 80vh;
      background: #020617;
      border-radius: 16px;
      border: 1px solid #1f2937;
      box-shadow: 0 25px 80px rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .modal-header {
      padding: 10px 14px 8px;
      border-bottom: 1px solid #1f2937;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }

    .modal-title {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--muted);
    }

    .modal-subtitle {
      font-size: 11px;
      color: var(--muted);
    }

    .modal-close {
      border-radius: 999px;
      border: 1px solid #4b5563;
      background: #020617;
      color: var(--muted);
      padding: 4px 10px;
      font-size: 11px;
      cursor: pointer;
    }

    .modal-body {
      padding: 8px 14px 12px;
      overflow: auto;
    }

    .modal-body table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .modal-body th,
    .modal-body td {
      padding: 6px 4px;
      border-bottom: 1px solid #111827;
      text-align: left;
    }

    .modal-body th {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--muted);
    }

    .modal-body th.sortable {
      cursor: pointer;
    }

    .modal-body th.sortable:hover {
      color: #e5e7eb;
    }

    .modal-body tr:nth-child(2n) td {
      background: rgba(15,23,42,0.75);
    }

    .modal-tag {
      display: inline-flex;
      padding: 2px 7px;
      border-radius: 999px;
      font-size: 10px;
      background: rgba(15,118,110,0.25);
      border: 1px solid rgba(45,212,191,0.5);
      color: #a7f3d0;
    }

    .empty-state {
      padding: 10px;
      font-size: 11px;
      color: var(--muted);
      text-align: center;
    }

    @media (max-width: 1024px) {
      body {
        padding: 12px;
      }
      .layout-grid {
        grid-template-columns: minmax(0,1fr);
      }
      .filters-row {
        grid-template-columns: minmax(0,1fr);
      }
      .kpi-row {
        grid-template-columns: repeat(2, minmax(0,1fr));
      }
    }
  </style>
</head>
<body>
<div class="page">
  <header class="header">
    <div class="title-block">
      <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">
        <div class="tag-live">
          <div class="tag-live-dot"></div>
          <span>Live ‚Ä¢ Design Recife</span>
        </div>
      </div>
      <h1>Painel de Produ√ß√£o ‚Äî Design Globo Recife</h1>
      <p>Monitoramento cont√≠nuo das demandas por produto, designer e tempo de execu√ß√£o.</p>
    </div>
    <div class="header-right">
      <div class="pill-row" id="yearPills">
        <!-- preenchido via JS -->
      </div>
      <div class="last-update" id="lastUpdateInfo">
        Carregando dados‚Ä¶
      </div>
    </div>
  </header>
	  <!-- Filtros principais -->
  <section class="filters-row">
    <!-- Per√≠odo / M√™s -->
    <div class="filter-chip-group">
      <div class="filter-label">
        <span>Per√≠odo (√∫ltimos 12 meses / ano)</span>
        <span id="periodSummary"></span>
      </div>
      <div class="filter-scroll" id="monthChips">
        <!-- chips de meses via JS -->
      </div>
    </div>

    <!-- Produtos (Buckets) -->
    <div class="filter-chip-group">
      <div class="filter-label">
        <span>Produtos (ordem alfab√©tica)</span>
        <span id="bucketSummary"></span>
      </div>
      <div class="filter-scroll" id="bucketChips">
        <!-- chips de buckets via JS -->
      </div>
    </div>

    <!-- Designers -->
    <div class="filter-chip-group">
      <div class="filter-label">
        <span>Designers (ordem alfab√©tica)</span>
        <span id="designerSummary"></span>
      </div>
      <div class="filter-scroll" id="designerChips">
        <!-- chips de designers via JS -->
      </div>
    </div>

    <!-- Busca por tarefa -->
    <div class="filter-chip-group">
      <div class="filter-label">
        <span>Filtro por demanda</span>
      </div>

      <div class="search-input-wrapper">
        <span class="search-icon">üîç</span>
        <input
          type="text"
          id="taskSearchInput"
          placeholder="filtrar por texto na descri√ß√£o da tarefa‚Ä¶ (Enter para buscar)"
        />
      </div>

      <div id="taskSearchStats" class="search-stats">
        Nenhum filtro de texto aplicado.
      </div>

      <div id="taskLastSearches" class="filter-scroll search-last-row">
        <!-- chips gerados via JS -->
      </div>
    </div>
  </section>

  <!-- KPIs e gr√°ficos -->
  <section class="layout-grid">
    <div>
      <!-- KPIs -->
      <div class="card">
        <div class="card-header">
          <div>
            <div class="card-title">Resumo do per√≠odo</div>
            <div class="card-subtitle" id="kpiPeriodLabel">‚Äî</div>
          </div>
        </div>
        <div class="kpi-row">
          <div class="kpi-card">
            <div class="kpi-label">Tarefas</div>
            <div class="kpi-value" id="kpiTotalTasks">‚Äî</div>
            <div class="kpi-foot">
              <span>Total filtrado</span>
              <span id="kpiTotalTasksFoot"></span>
            </div>
          </div>
          <div class="kpi-card">
            <div class="kpi-label">Horas totais</div>
            <div class="kpi-value" id="kpiTotalHours">‚Äî</div>
            <div class="kpi-foot">
              <span>Somat√≥rio do per√≠odo</span>
              <span id="kpiTotalHoursFoot"></span>
            </div>
          </div>
          <div class="kpi-card">
            <div class="kpi-label">Tempo m√©dio</div>
            <div class="kpi-value" id="kpiAvgDuration">‚Äî</div>
            <div class="kpi-foot">
              <span>por tarefa</span>
              <span id="kpiAvgDurationFoot"></span>
            </div>
          </div>
          <div class="kpi-card">
            <div class="kpi-label">Tempo mediano</div>
            <div class="kpi-value" id="kpiMedianDuration">‚Äî</div>
            <div class="kpi-foot">
              <span>robusto a outliers</span>
              <span id="kpiMedianDurationFoot"></span>
            </div>
          </div>
          <div class="kpi-card">
            <div class="kpi-label">Horas extras</div>
            <div class="kpi-value" id="kpiHeHours">‚Äî</div>
            <div class="kpi-foot">
              <span>acima de 9h/dia*</span>
              <span id="kpiHeHoursFoot"></span>
            </div>
          </div>
        </div>
      </div>

      <!-- Evolu√ß√£o mensal -->
      <div class="card" style="margin-top: 14px;">
        <div class="card-header">
          <div>
            <div class="card-title">Evolu√ß√£o mensal</div>
            <div class="card-subtitle" id="monthlySubtitle">
              Volume de demandas ao longo dos meses filtrados.
              Clique em uma coluna para ver o detalhamento di√°rio do m√™s.
            </div>
          </div>
          <div class="pill-toggle" id="monthlyModeToggle">
            <button data-mode="tasks" class="active">Tarefas</button>
            <button data-mode="hours">Horas</button>
          </div>
        </div>
        <div class="chart-container chart-container-tall">
          <canvas id="monthlyChart"></canvas>
        </div>
      </div>
    </div>

    <div>
      <!-- Perfil de tempo -->
      <div class="card">
        <div class="card-header">
          <div>
            <div class="card-title">Perfil de tempo</div>
            <div class="card-subtitle">
              Distribui√ß√£o das tarefas por faixa de dura√ß√£o (minutos).
              Clique em uma faixa para ver todas as tarefas, com tabela orden√°vel.
            </div>
          </div>
        </div>
        <div class="time-badges" id="timeSegments">
          <!-- cards via JS -->
        </div>
      </div>

      <!-- Ranking de designers -->
      <div class="card" style="margin-top: 14px;">
        <div class="card-header">
          <div>
            <div class="card-title">Ranking de designers</div>
            <div class="card-subtitle">Quem mais participou no per√≠odo filtrado.</div>
          </div>
          <div class="pill-toggle" id="designerModeToggle">
            <button data-mode="tasks" class="active">Tarefas</button>
            <button data-mode="hours">Horas</button>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="designerChart"></canvas>
        </div>
      </div>
    </div>
  </section>

  <!-- Segunda linha: Produtos -->
  <section class="layout-grid">
    <!-- Volume por produto -->
    <div class="card">
      <div class="card-header">
        <div>
          <div class="card-title">Volume por produto</div>
          <div class="card-subtitle">Top produtos dentro dos filtros atuais.</div>
        </div>
        <div class="pill-toggle" id="bucketModeToggle">
          <button data-mode="tasks" class="active">Tarefas</button>
          <button data-mode="hours">Horas</button>
        </div>
      </div>
      <div class="chart-container chart-container-tall">
        <canvas id="bucketChart"></canvas>
      </div>
    </div>

    <!-- Notas do per√≠odo -->
    <div class="card">
      <div class="card-header">
        <div>
          <div class="card-title">Notas do per√≠odo</div>
          <div class="card-subtitle">Resumo qualitativo com base nos filtros aplicados.</div>
        </div>
      </div>
      <div style="font-size:13px;color:var(--muted);line-height:1.5;">
        <p id="qualitativeSummary">
          Ajuste os filtros de ano, m√™s, produto, designer e texto da tarefa para ver aqui uma leitura r√°pida
          sobre a carga de trabalho da equipe de design.
        </p>
        <ul id="qualitativeBullets" style="padding-left:18px;margin:0;list-style:disc;">
          <!-- preenchido via JS -->
        </ul>
      </div>
    </div>
  </section>
</div>

<!-- Modal de lista de tarefas por faixa de tempo -->
<div class="modal-backdrop" id="modalBackdrop">
  <div class="modal">
    <div class="modal-header">
      <div>
        <div class="modal-title" id="modalTitle">FAIXA DE TEMPO</div>
        <div class="modal-subtitle" id="modalSubtitle">‚Äî</div>
      </div>
      <button class="modal-close" id="modalCloseButton">Fechar</button>
    </div>
    <div class="modal-body">
      <div id="modalTableContainer">
        <!-- tabela via JS -->
      </div>
    </div>
  </div>
</div>

<!-- Modal de evolu√ß√£o no m√™s (drill-down da evolu√ß√£o mensal) -->
<div class="modal-backdrop" id="monthDrillBackdrop">
  <div class="modal">
    <div class="modal-header">
      <div>
        <div class="modal-title" id="monthDrillTitle">EVOLU√á√ÉO NO M√äS</div>
        <div class="modal-subtitle" id="monthDrillSubtitle">‚Äî</div>
      </div>
      <button class="modal-close" id="monthDrillCloseButton">Fechar</button>
    </div>
    <div class="modal-body">
      <div class="chart-container chart-container-tall" style="height:260px;">
        <canvas id="monthDrillChart"></canvas>
      </div>
    </div>
  </div>
</div>
<script>
/**********************************************************
 * CONFIG
 **********************************************************/
console.log("[DASHBOARD] Script JS carregado.");

const API_URL =
  "https://script.google.com/macros/s/AKfycbzT5urDXekkyDU8FgkZ_zv6WaQZsjvLAT0DNh3tzwQB2OXxoKqJk7jRZqXflAWM4aqOIA/exec";

let rawData = [];
let filteredData = [];

// busca por texto
let lastFilteredCount = 0;
const lastTaskSearches = []; // { term, count }

// controla se √© a primeira carga de dados
let isFirstLoad = true;

// estado global de UI
const state = {
  currentYear: null,      // null = rolling 12 meses
  selectedMonth: null,    // 0..11 ou null
  selectedBucket: null,
  selectedDesigner: null,
  taskSearch: "",
  monthlyMetric: "tasks",   // "tasks" | "hours"
  bucketMetric: "tasks",    // "tasks" | "hours"
  designerMetric: "tasks"   // "tasks" | "hours"
};

/**********************************************************
 * SISTEMA DE CORES / FILTRO POR MODO DE TRABALHO
 **********************************************************/
const workModeView = {
  showHO:   true,
  showPRES: true,
  showFLEX: true
};

// Paleta oficial (caso voc√™ queira usar depois nos gr√°ficos)
function modeToColor(mode) {
  switch ((mode || "").toUpperCase()) {
    case "HO":   return "#0A84FF"; // azul (home office)
    case "FLEX": return "#FFD60A"; // amarelo (flex√≠vel)
    case "PRES": return "#34C759"; // verde (presencial)
    default:     return "#8E8E93"; // cinza
  }
}

function normalizeWorkMode(mode) {
  if (!mode) return "";
  const m = String(mode).trim().toUpperCase();
  if (m === "HO")   return "HO";
  if (m === "HOME" || m === "HOME OFFICE") return "HO";
  if (m === "PRES" || m === "PRESENCIAL")  return "PRES";
  if (m === "FLEX" || m === "H√çBRIDO" || m === "HIBRIDO") return "FLEX";
  return "OTHER";
}

// Verifica se o modo deve ser exibido visualmente
function isModeVisible(modeNorm) {
  const m = (modeNorm || "").toUpperCase();
  if (m === "HO")   return workModeView.showHO;
  if (m === "PRES") return workModeView.showPRES;
  if (m === "FLEX") return workModeView.showFLEX;
  return true; // OTHER n√£o √© filtrado
}

/**********************************************************
 * FAIXAS DE TEMPO
 **********************************************************/
const timeSegments = [
  { id: "lt20",   label: "< 20 min",     min: 0,   max: 20 },
  { id: "20_40",  label: "20‚Äì40 min",    min: 20,  max: 40 },
  { id: "40_60",  label: "40‚Äì60 min",    min: 40,  max: 60 },
  { id: "60_120", label: "60‚Äì120 min",   min: 60,  max: 120 },
  { id: "gt120",  label: "> 120 min",    min: 120, max: Infinity },
  { id: "noTime", label: "Sem dura√ß√£o",  special: "noTime" }
];

const timeSegmentData = {}; // id -> { count, totalMinutes, tasks }

let monthlyChart = null;
let designerChart = null;
let bucketChart = null;
let monthDrillChart = null; // gr√°fico do modal de drill-down mensal

// estado do modal de perfil de tempo (todas as tarefas, ordena√ß√£o)
let modalTasks = [];
let modalSortKey = "date";   // "date" | "bucket" | "designer" | "task" | "duration"
let modalSortDir = "desc";   // "asc" | "desc"

/**********************************************************
 * UTILIDADES
 **********************************************************/
function parseDateSafe(str) {
  if (!str) return null;
  const m = str.match(/^(\d{4})-(\d{2})-(\d{2})/);
  if (m) {
    const y = +m[1], mo = +m[2], d = +m[3];
    return new Date(y, mo - 1, d);
  }
  const d2 = new Date(str);
  return isNaN(d2.getTime()) ? null : d2;
}

function formatMonthLabel(date) {
  const months = ["jan","fev","mar","abr","mai","jun","jul","ago","set","out","nov","dez"];
  return months[date.getMonth()] + "/" + String(date.getFullYear()).slice(-2);
}

function formatMonthFull(date) {
  const months = [
    "janeiro","fevereiro","mar√ßo","abril","maio","junho",
    "julho","agosto","setembro","outubro","novembro","dezembro"
  ];
  return months[date.getMonth()] + " de " + date.getFullYear();
}

function formatMinutesToHM(mins) {
  if (mins == null || isNaN(mins)) return "‚Äî";
  const total = Math.round(mins);
  const h = Math.floor(total / 60);
  const m = total % 60;
  if (h === 0) return `${m} min`;
  if (m === 0) return `${h} h`;
  return `${h} h ${m} min`;
}

function median(arr) {
  if (!arr || arr.length === 0) return null;
  const sorted = [...arr].sort((a,b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  if (sorted.length % 2 === 0) {
    return (sorted[mid - 1] + sorted[mid]) / 2;
  } else {
    return sorted[mid];
  }
}

function formatShortDate(d) {
  const day = String(d.getDate()).padStart(2, "0");
  const mo = String(d.getMonth() + 1).padStart(2, "0");
  const y = d.getFullYear();
  return `${day}/${mo}/${y}`;
}

function weekdayFromDate(d) {
  const names = ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "S√°b"];
  return names[d.getDay()] || "";
}

/**
 * Utils para c√°lculo de HE por dia+designer
 * - Primeiro nome
 * - Remo√ß√£o de acentos
 * - Cap di√°rio: 9h (540min) designers, 6h (360min) Jo√£o
 */
function getFirstName(user) {
  if (!user) return "";
  return String(user).trim().split(/\s+/)[0];
}

function normalizeName(str) {
  if (!str) return "";
  return str
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase();
}

function getDailyCapMinutesForUser(user) {
  const first = normalizeName(getFirstName(user));
  if (!first) return 9 * 60;
  if (first === "joao") {
    // estagi√°rio
    return 6 * 60;
  }
  return 9 * 60;
}

/**********************************************************
 * BUSCA POR TEXTO ‚Äî chips e stats
 **********************************************************/
function renderTaskLastSearchChips() {
  const container = document.getElementById("taskLastSearches");
  container.innerHTML = "";
  if (!lastTaskSearches.length) return;

  lastTaskSearches.forEach(entry => {
    const chip = document.createElement("div");
    chip.className = "chip";
    chip.textContent = entry.term;
    chip.title = `Foram encontradas ${entry.count} ocorr√™ncias na √∫ltima busca.`;
    chip.onclick = () => {
      const input = document.getElementById("taskSearchInput");
      input.value = entry.term;
      state.taskSearch = entry.term;
      applyFiltersAndRender();
    };
    container.appendChild(chip);
  });
}

function updateTaskSearchStats() {
  const el = document.getElementById("taskSearchStats");
  const term = (state.taskSearch || "").trim();

  if (!term) {
    el.textContent = "Nenhum filtro de texto aplicado.";
    return;
  }

  el.textContent = `Foram encontradas ${lastFilteredCount} ocorr√™ncias.`;
}

function registerTaskSearch(term, count) {
  const clean = term.trim();
  if (!clean) return;

  const idx = lastTaskSearches.findIndex(e => e.term === clean);
  if (idx !== -1) {
    lastTaskSearches.splice(idx, 1);
  }

  lastTaskSearches.unshift({ term: clean, count: count || 0 });
  if (lastTaskSearches.length > 5) {
    lastTaskSearches.length = 5;
  }

  renderTaskLastSearchChips();
}

/**********************************************************
 * PER√çODO PADR√ÉO
 **********************************************************/
function applyDefaultPeriod() {
  if (!rawData.length) return;
  const maxDate = rawData.reduce((a,b) => a.dateObj > b.dateObj ? a : b).dateObj;
  state.currentYear = null;
  state.selectedMonth = null;
  updateYearPills();
  updateMonthChipsActive();
}

/**********************************************************
 * ANOS (pills do topo) + MESES (chips)
 **********************************************************/
function buildYearPills() {
  const container = document.getElementById("yearPills");
  container.innerHTML = "";

  if (!rawData.length) return;

  const yearSet = new Set(
    rawData
      .map(d => d.dateObj)
      .filter(d => d instanceof Date && !isNaN(d.getTime()))
      .map(d => d.getFullYear())
  );
  const years = Array.from(yearSet).sort((a, b) => b - a);

  const rollingBtn = document.createElement("button");
  rollingBtn.className = "pill";
  rollingBtn.dataset.year = "rolling";
  rollingBtn.textContent = "√öltimos 12 meses";
  rollingBtn.onclick = () => {
    state.currentYear = null;
    state.selectedMonth = null;
    updateYearPills();
    updateMonthChipsActive();
    applyFiltersAndRender();
  };
  container.appendChild(rollingBtn);

  years.forEach(y => {
    const btn = document.createElement("button");
    btn.className = "pill";
    btn.dataset.year = String(y);
    btn.textContent = String(y);
    btn.onclick = () => {
      state.currentYear = y;
      state.selectedMonth = null;
      updateYearPills();
      updateMonthChipsActive();
      applyFiltersAndRender();
    };
    container.appendChild(btn);
  });

  updateYearPills();
}

function updateYearPills() {
  const container = document.getElementById("yearPills");
  const pills = Array.from(container.querySelectorAll(".pill"));

  pills.forEach(btn => {
    const val = btn.dataset.year;
    const isRolling = (val === "rolling" && state.currentYear === null);
    const isYear =
      state.currentYear !== null && String(state.currentYear) === val;

    if (isRolling || isYear) {
      btn.classList.add("active");
    } else {
      btn.classList.remove("active");
    }
  });
}

function buildMonthChips() {
  const container = document.getElementById("monthChips");
  container.innerHTML = "";

  if (!rawData.length) return;

  const monthLabels = [
    "Jan","Fev","Mar","Abr","Mai","Jun",
    "Jul","Ago","Set","Out","Nov","Dez"
  ];

  monthLabels.forEach((label, idx) => {
    const chip = document.createElement("div");
    chip.className = "chip";
    chip.dataset.monthIndex = String(idx);
    chip.textContent = label;

    chip.onclick = () => {
      if (state.selectedMonth === idx) {
        state.selectedMonth = null;
      } else {
        state.selectedMonth = idx;
      }
      updateMonthChipsActive();
      applyFiltersAndRender();
    };

    container.appendChild(chip);
  });

  updateMonthChipsActive();
}

function updateMonthChipsActive() {
  const container = document.getElementById("monthChips");
  if (!container || !rawData.length) return;

  let baseList = [...rawData];

  const validDates = baseList
    .map(d => d.dateObj)
    .filter(d => d instanceof Date && !isNaN(d.getTime()));
  if (!validDates.length) return;

  const maxDate = validDates.reduce((a, b) => (a > b ? a : b));

  if (state.currentYear === null) {
    const end = new Date(maxDate.getFullYear(), maxDate.getMonth(), 1);
    const start = new Date(end.getFullYear(), end.getMonth() - 11, 1);
    baseList = baseList.filter(d => {
      const dt = d.dateObj;
      if (!dt) return false;
      const firstOfMonth = new Date(dt.getFullYear(), dt.getMonth(), 1);
      return firstOfMonth >= start && firstOfMonth <= end;
    });
  } else {
    baseList = baseList.filter(
      d => d.dateObj && d.dateObj.getFullYear() === state.currentYear
    );
  }

  const monthsAvailable = new Map(); // monthIndex -> Set(years)
  baseList.forEach(d => {
    const dt = d.dateObj;
    if (!dt) return;
    const m = dt.getMonth();
    const y = dt.getFullYear();
    if (!monthsAvailable.has(m)) {
      monthsAvailable.set(m, new Set());
    }
    monthsAvailable.get(m).add(y);
  });

  Array.from(container.querySelectorAll(".chip")).forEach(chip => {
    const idx = Number(chip.dataset.monthIndex);
    const baseLabel = chip.dataset.baseLabel || chip.textContent.slice(0, 3);

    if (state.selectedMonth === idx) {
      chip.classList.add("active");
    } else {
      chip.classList.remove("active");
    }

    const years = monthsAvailable.get(idx);
    if (!years || years.size === 0) {
      chip.textContent = baseLabel;
      return;
    }

    if (years.size === 1) {
      const onlyYear = [...years][0];
      chip.textContent = `${baseLabel}/${String(onlyYear).slice(-2)}`;
    } else {
      const sorted = [...years].sort();
      const first = String(sorted[0]).slice(-2);
      const last = String(sorted[sorted.length - 1]).slice(-2);
      chip.textContent = `${baseLabel} ‚Ä¢ ${first}-${last}`;
    }
  });
}

/**********************************************************
 * BUCKETS (produtos) ‚Äî chips
 **********************************************************/
function buildBucketChips() {
  const container = document.getElementById("bucketChips");
  container.innerHTML = "";

  if (!rawData.length) return;

  const buckets = Array.from(
    new Set(
      rawData
        .map(d => d.bucket)
        .filter(Boolean)
    )
  ).sort((a, b) => a.localeCompare(b, "pt-BR"));

  buckets.forEach(bucket => {
    const chip = document.createElement("div");
    chip.className = "chip";
    chip.dataset.bucket = bucket;

    const spanLabel = document.createElement("span");
    spanLabel.textContent = bucket;
    chip.appendChild(spanLabel);

    chip.onclick = () => {
      if (state.selectedBucket === bucket) {
        state.selectedBucket = null;
      } else {
        state.selectedBucket = bucket;
      }
      updateBucketChipsActive();
      applyFiltersAndRender();
    };

    container.appendChild(chip);
  });

  updateBucketChipsActive();
}

function updateBucketChipsActive() {
  const container = document.getElementById("bucketChips");
  Array.from(container.querySelectorAll(".chip")).forEach(chip => {
    const bucket = chip.dataset.bucket;
    if (bucket === state.selectedBucket) {
      chip.classList.add("active");
    } else {
      chip.classList.remove("active");
    }
  });

  const label = document.getElementById("bucketSummary");
  label.textContent = state.selectedBucket ? state.selectedBucket : "Todos";
}

/**********************************************************
 * DESIGNERS ‚Äî chips
 **********************************************************/
function buildDesignerChips() {
  const container = document.getElementById("designerChips");
  container.innerHTML = "";

  const designers = Array.from(new Set(rawData.map(d => d.user).filter(Boolean)))
    .sort();

  designers.forEach(des => {
    const chip = document.createElement("div");
    chip.className = "chip";
    chip.dataset.designer = des;
    const spanLabel = document.createElement("span");
    spanLabel.textContent = des;
    chip.appendChild(spanLabel);
    chip.onclick = () => {
      if (state.selectedDesigner === des) {
        state.selectedDesigner = null;
      } else {
        state.selectedDesigner = des;
      }
      updateDesignerChipsActive();
      applyFiltersAndRender();
    };
    container.appendChild(chip);
  });
}

function updateDesignerChipsActive() {
  const container = document.getElementById("designerChips");
  Array.from(container.querySelectorAll(".chip")).forEach(chip => {
    const des = chip.dataset.designer;
    if (des === state.selectedDesigner) {
      chip.classList.add("active");
    } else {
      chip.classList.remove("active");
    }
  });

  const label = document.getElementById("designerSummary");
  label.textContent = state.selectedDesigner ? state.selectedDesigner : "Todos";
}

/**********************************************************
 * FILTRO POR MODO ‚Äî PILLS NO TOPO
 **********************************************************/
function buildWorkModePills() {
  const headerRight = document.querySelector(".header-right");
  if (!headerRight) return;

  // Se j√° existe a linha, n√£o recria
  let row = document.getElementById("workModeRow");
  if (row) return;

  row = document.createElement("div");
  row.className = "pill-row";
  row.id = "workModeRow";

  // pill de label
  const label = document.createElement("button");
  label.className = "pill";
  label.textContent = "Modo de trabalho";
  label.disabled = true;
  label.style.opacity = "0.85";
  row.appendChild(label);

  const modes = [
    { id: "FLEX", key: "showFLEX" },
    { id: "PRES", key: "showPRES" },
    { id: "HO",   key: "showHO" }
  ];

  modes.forEach(m => {
    const btn = document.createElement("button");
    btn.className = "pill active";
    btn.dataset.mode = m.id;
    btn.textContent = m.id;
    row.appendChild(btn);
  });

  // insere antes do seletor de ano
  const yearPills = document.getElementById("yearPills");
  if (yearPills && yearPills.parentElement === headerRight) {
    headerRight.insertBefore(row, yearPills);
  } else {
    headerRight.insertBefore(row, headerRight.firstChild);
  }
}
/**********************************************************
 * FILTRAGEM
 **********************************************************/
function applyFiltersAndRender() {
  if (!rawData.length) {
    filteredData = [];
    renderAll();
    return;
  }

  let list = [...rawData];

  // garante s√≥ registros com dateObj v√°lido
  list = list.filter(d => d.dateObj instanceof Date && !isNaN(d.dateObj.getTime()));

  const dates = list.map(d => d.dateObj);
  const maxDate = dates.reduce((a, b) => (a > b ? a : b));

  // recorte de per√≠odo: √∫ltimos 12 meses ou ano fechado
  if (state.currentYear === null) {
    const end = new Date(maxDate.getFullYear(), maxDate.getMonth(), 1);
    const start = new Date(end.getFullYear(), end.getMonth() - 11, 1);
    list = list.filter(d => {
      const dt = d.dateObj;
      const firstOfMonth = new Date(dt.getFullYear(), dt.getMonth(), 1);
      return firstOfMonth >= start && firstOfMonth <= end;
    });
  } else {
    list = list.filter(d => d.dateObj.getFullYear() === state.currentYear);
  }

  // recorte por m√™s espec√≠fico (chip de m√™s)
  if (state.selectedMonth !== null) {
    list = list.filter(d => d.dateObj.getMonth() === state.selectedMonth);
  }

  // filtro por produto (bucket)
  if (state.selectedBucket) {
    list = list.filter(d => d.bucket === state.selectedBucket);
  }

  // filtro por designer
  if (state.selectedDesigner) {
    list = list.filter(d => d.user === state.selectedDesigner);
  }

  // filtro por texto na tarefa
  const search = (state.taskSearch || "").toLowerCase().trim();
  if (search) {
    list = list.filter(d => (d.task || "").toLowerCase().includes(search));
  }

  // filtro por modo de trabalho
  list = list.filter(d => isModeVisible(d.modeNorm));

  filteredData = list;
  lastFilteredCount = filteredData.length;
  updateTaskSearchStats();
  updatePeriodSummary();
  renderAll();
}
/**********************************************************
 * RESUMO DE PER√çODO
 **********************************************************/
function updatePeriodSummary() {
  const el = document.getElementById("periodSummary");
  const kpiLabel = document.getElementById("kpiPeriodLabel");

  if (!filteredData.length) {
    el.textContent = "Sem dados";
    kpiLabel.textContent = "Sem dados no recorte atual";
    return;
  }

  const sorted = [...filteredData].sort((a,b) => a.dateObj - b.dateObj);
  const first = sorted[0].dateObj;
  const last  = sorted[sorted.length - 1].dateObj;

  const rangeStr = `${formatShortDate(first)} ‚Äî ${formatShortDate(last)}`;
  el.textContent = rangeStr;
  kpiLabel.textContent = rangeStr;
}

/**********************************************************
 * RENDERIZA√á√ÉO GERAL
 **********************************************************/
function renderAll() {
  renderKpis();
  renderTimeSegments();
  renderMonthlyChart();
  renderDesignerChart();
  renderBucketChart();
  renderQualitativeSummary();
}

/**********************************************************
 * KPIs (inclui Horas Extras)
 **********************************************************/
function renderKpis() {
  const totalTasks = filteredData.length;
  const durations = filteredData
    .map(d => d.durationMinutes)
    .filter(v => typeof v === "number" && v > 0);

  const totalMinutes = durations.reduce((sum,v) => sum + v, 0);
  const avg = durations.length ? totalMinutes / durations.length : null;
  const med = durations.length ? median(durations) : null;

  // HE por dia+designer (j√° respeitando modo de trabalho, pois vem de filteredData)
  let totalHeMinutes = 0;
  if (filteredData.length) {
    const groups = new Map(); // key: yyyy-MM-dd||user -> { minutes, user, date }

    filteredData.forEach(d => {
      if (!(d.dateObj instanceof Date)) return;
      const keyDate = d.dateObj.toISOString().slice(0, 10);
      const key = keyDate + "||" + (d.user || "");
      if (!groups.has(key)) {
        groups.set(key, { minutes: 0, user: d.user || "", date: d.dateObj });
      }
      const m = typeof d.durationMinutes === "number" ? d.durationMinutes : 0;
      groups.get(key).minutes += m;
    });

    groups.forEach(g => {
      const cap = getDailyCapMinutesForUser(g.user); // 9h ou 6h
      const he = Math.max(0, g.minutes - cap);
      totalHeMinutes += he;
    });
  }

  document.getElementById("kpiTotalTasks").textContent =
    totalTasks.toLocaleString("pt-BR");
  document.getElementById("kpiTotalTasksFoot").textContent =
    durations.length ? `${durations.length} c/ tempo registrado` : "Sem tempos";

  document.getElementById("kpiTotalHours").textContent =
    (totalMinutes / 60 || 0).toFixed(1).replace(".", ",");
  document.getElementById("kpiTotalHoursFoot").textContent =
    totalMinutes ? `${Math.round(totalMinutes)} min no per√≠odo` : "‚Äî";

  document.getElementById("kpiAvgDuration").textContent = formatMinutesToHM(avg);
  document.getElementById("kpiAvgDurationFoot").textContent =
    avg ? `${Math.round(avg)} min/tarefa` : "‚Äî";

  document.getElementById("kpiMedianDuration").textContent = formatMinutesToHM(med);
  document.getElementById("kpiMedianDurationFoot").textContent =
    med ? `${Math.round(med)} min (mediana)` : "‚Äî";

  // KPI de Horas Extras
  const heHours = totalHeMinutes / 60;
  document.getElementById("kpiHeHours").textContent =
    heHours ? heHours.toFixed(1).replace(".", ",") : "0,0";
  document.getElementById("kpiHeHoursFoot").textContent =
    totalHeMinutes
      ? `${Math.round(totalHeMinutes)} min acima do limite di√°rio`
      : "sem HE no recorte";
}

/**********************************************************
 * PERFIL DE TEMPO (cards + prepara√ß√£o para modal completo)
 **********************************************************/
function renderTimeSegments() {
  const container = document.getElementById("timeSegments");
  container.innerHTML = "";

  timeSegments.forEach(seg => {
    timeSegmentData[seg.id] = { count: 0, totalMinutes: 0, tasks: [] };
  });

  filteredData.forEach(d => {
    const dur = d.durationMinutes;

    if (!dur || dur <= 0) {
      const entryNo = timeSegmentData["noTime"];
      if (entryNo) {
        entryNo.count++;
        entryNo.tasks.push(d);
      }
      return;
    }

    for (const seg of timeSegments) {
      if (seg.id === "noTime") continue;

      if (seg.max === Infinity) {
        if (dur > seg.min) {
          const entry = timeSegmentData[seg.id];
          entry.count++;
          entry.totalMinutes += dur;
          entry.tasks.push(d);
          return;
        }
      } else if (dur > seg.min && dur <= seg.max) {
        const entry = timeSegmentData[seg.id];
        entry.count++;
        entry.totalMinutes += dur;
        entry.tasks.push(d);
        return;
      }
    }
  });

  timeSegments.forEach(seg => {
    const entry = timeSegmentData[seg.id];
    const card = document.createElement("div");
    card.className = "time-badge";
    if (seg.id === "gt120") {
      card.classList.add("segment-danger");
    }
    card.onclick = () => openTimeSegmentModal(seg);

    const label = document.createElement("div");
    label.className = "time-badge-label";
    label.textContent = seg.label;
    card.appendChild(label);

    const main = document.createElement("div");
    main.className = "time-badge-main";

    const value = document.createElement("div");
    value.className = "time-badge-value";
    value.textContent = entry.count.toLocaleString("pt-BR");
    main.appendChild(value);

    const mini = document.createElement("div");
    mini.style.fontSize = "11px";
    mini.style.color = "var(--muted)";

    if (seg.id === "noTime") {
      mini.textContent = entry.count
        ? "sem dura√ß√£o registrada"
        : "‚Äî";
    } else {
      mini.textContent = entry.totalMinutes
        ? formatMinutesToHM(entry.totalMinutes)
        : "‚Äî";
    }
    main.appendChild(mini);

    card.appendChild(main);

    const foot = document.createElement("div");
    foot.className = "time-badge-foot";
    if (seg.id === "noTime") {
      foot.textContent = entry.count
        ? "tarefas sem tempo mapeado"
        : "sem tarefas nesta condi√ß√£o";
    } else {
      foot.textContent = entry.count
        ? `m√©dia ${formatMinutesToHM(entry.totalMinutes / entry.count)}`
        : "sem tarefas nesta faixa";
    }
    card.appendChild(foot);

    container.appendChild(card);
  });
}

/**********************************************************
 * GR√ÅFICO MENSAL (com drill-down)
 **********************************************************/
function renderMonthlyChart() {
  if (monthlyChart) {
    monthlyChart.destroy();
    monthlyChart = null;
  }

  const canvas = document.getElementById("monthlyChart");
  const ctx = canvas.getContext("2d");
  canvas.onclick = null;

  if (!filteredData.length) {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    return;
  }

  // Agrega por ano-m√™s
  const monthMap = new Map();
  filteredData.forEach(d => {
    const dt = d.dateObj;
    if (!dt) return;
    const key = dt.getFullYear() + "-" + String(dt.getMonth() + 1).padStart(2, "0");
    if (!monthMap.has(key)) {
      monthMap.set(key, {
        year: dt.getFullYear(),
        monthIndex: dt.getMonth(),
        date: new Date(dt.getFullYear(), dt.getMonth(), 1),
        tasks: 0,
        minutes: 0
      });
    }
    const agg = monthMap.get(key);
    agg.tasks++;
    if (typeof d.durationMinutes === "number") {
      agg.minutes += d.durationMinutes;
    }
  });

  const monthRows = Array.from(monthMap.values()).sort((a, b) => a.date - b.date);

  // Se s√≥ h√° 1 m√™s, desenha evolu√ß√£o di√°ria direto no card
  if (monthRows.length === 1) {
    const m = monthRows[0];
    const dailyMap = new Map();

    filteredData.forEach(d => {
      const dt = d.dateObj;
      if (!dt) return;
      if (dt.getFullYear() !== m.year || dt.getMonth() !== m.monthIndex) return;
      const day = dt.getDate();
      if (!dailyMap.has(day)) {
        dailyMap.set(day, { day, tasks: 0, minutes: 0 });
      }
      const agg = dailyMap.get(day);
      agg.tasks++;
      if (typeof d.durationMinutes === "number") {
        agg.minutes += d.durationMinutes;
      }
    });

    const dayRows = Array.from(dailyMap.values()).sort((a, b) => a.day - b.day);

    const labels = dayRows.map(r => String(r.day).padStart(2, "0"));
    const tasksArr = dayRows.map(r => r.tasks);
    const hoursArr = dayRows.map(r => r.minutes / 60);
    const avgMinArr = dayRows.map(r =>
      r.tasks ? (r.minutes / r.tasks) : 0
    );

    const barData   = state.monthlyMetric === "tasks" ? tasksArr : hoursArr;
    const lineData  = state.monthlyMetric === "tasks" ? hoursArr : tasksArr;
    const barLabel  = state.monthlyMetric === "tasks" ? "Tarefas/dia" : "Horas/dia";
    const lineLabel = state.monthlyMetric === "tasks" ? "Horas/dia" : "Tarefas/dia";

    monthlyChart = new Chart(ctx, {
      type: "bar",
      data: {
        labels,
        datasets: [
          {
            type: "bar",
            label: barLabel,
            data: barData,
            backgroundColor: "rgba(56,189,248,0.45)",
            borderRadius: 4,
            yAxisID: "yMain"
          },
          {
            type: "line",
            label: lineLabel,
            data: lineData,
            borderColor: "#f97373",
            backgroundColor: "rgba(248,113,113,0.25)",
            tension: 0.3,
            fill: false,
            pointRadius: 3,
            yAxisID: "yAux"
          },
          {
            type: "line",
            label: "Tempo m√©dio por tarefa (min)",
            data: avgMinArr,
            borderColor: "#a855f7",
            backgroundColor: "rgba(168,85,247,0.25)",
            tension: 0.3,
            fill: false,
            pointRadius: 2,
            borderDash: [4, 3],
            yAxisID: "yAvg"
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: true,
            labels: { color: "#e5e7eb", font: { size: 11 } }
          },
          tooltip: {
            callbacks: {
              label: (ctx) => {
                const label = ctx.dataset.label || "";
                const v = ctx.parsed.y;
                if (label.includes("Tarefa")) {
                  return `${label}: ${v}`;
                }
                if (label.includes("Hora")) {
                  return `${label}: ${v.toFixed(1).replace(".", ",")} h`;
                }
                if (label.startsWith("Tempo m√©dio")) {
                  return `${label}: ${v.toFixed(0)} min`;
                }
                return `${label}: ${v}`;
              }
            }
          }
        },
        scales: {
          x: {
            ticks: { color: "#9ca3af", font: { size: 11 } },
            grid: { display: false }
          },
          yMain: {
            position: "left",
            ticks: {
              color: "#9ca3af",
              font: { size: 11 },
              callback: (value) => {
                if (state.monthlyMetric === "tasks") {
                  return value;
                } else {
                  return value.toFixed(1).replace(".", ",") + " h";
                }
              }
            },
            grid: { color: "#1f2937" }
          },
          yAux: {
            position: "right",
            ticks: {
              color: "#6b7280",
              font: { size: 10 },
              callback: (value) => {
                if (state.monthlyMetric === "tasks") {
                  return value.toFixed(1).replace(".", ",") + " h";
                } else {
                  return value;
                }
              }
            },
            grid: { display: false }
          },
          yAvg: {
            position: "right",
            offset: true,
            ticks: {
              color: "#a855f7",
              font: { size: 10 },
              callback: (value) => `${value.toFixed(0)} min`
            },
            grid: { display: false }
          }
        }
      }
    });

    // Atualiza especificamente o t√≠tulo/sub do card "Evolu√ß√£o mensal"
    const monthlyCard = document.getElementById("monthlySubtitle")?.closest(".card");
    if (monthlyCard) {
      const titleEl = monthlyCard.querySelector(".card-title");
      const subEl   = monthlyCard.querySelector(".card-subtitle");
      if (titleEl && subEl) {
        titleEl.textContent = "Evolu√ß√£o no m√™s";
        subEl.textContent = `Evolu√ß√£o di√°ria em ${formatMonthFull(m.date)} no recorte atual.`;
      }
    }

    return;
  }

  // Cen√°rio padr√£o: v√°rios meses
  const labels   = monthRows.map(r => formatMonthLabel(r.date));
  const tasksArr = monthRows.map(r => r.tasks);
  const hoursArr = monthRows.map(r => r.minutes / 60);
  const avgMinArr = monthRows.map(r =>
    r.tasks ? (r.minutes / r.tasks) : 0
  );

  const barData   = state.monthlyMetric === "tasks" ? tasksArr : hoursArr;
  const lineData  = state.monthlyMetric === "tasks" ? hoursArr : tasksArr;
  const barLabel  = state.monthlyMetric === "tasks" ? "Tarefas" : "Horas";
  const lineLabel = state.monthlyMetric === "tasks" ? "Horas" : "Tarefas";

  monthlyChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          type: "bar",
          label: barLabel,
          data: barData,
          backgroundColor: "rgba(56,189,248,0.45)",
          borderRadius: 4,
          yAxisID: "yMain"
        },
        {
          type: "line",
          label: lineLabel,
          data: lineData,
          borderColor: "#f97373",
          backgroundColor: "rgba(248,113,113,0.25)",
          tension: 0.3,
          fill: false,
          pointRadius: 3,
          yAxisID: "yAux"
        },
        {
          type: "line",
          label: "Tempo m√©dio por tarefa (min)",
          data: avgMinArr,
          borderColor: "#a855f7",
          backgroundColor: "rgba(168,85,247,0.25)",
          tension: 0.3,
          fill: false,
          pointRadius: 2,
          borderDash: [4, 3],
          yAxisID: "yAvg"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          ticks: { color: "#9ca3af", font: { size: 11 } },
          grid: { display: false }
        },
        yMain: {
          position: "left",
          ticks: {
            color: "#9ca3af",
            font: { size: 11 },
            callback: (value) => {
              if (state.monthlyMetric === "tasks") {
                return value;
              } else {
                return value.toFixed(1).replace(".", ",") + " h";
              }
            }
          },
          grid: { color: "#1f2937"}
        },
        yAux: {
          position: "right",
          ticks: {
            color: "#6b7280",
            font: { size: 10 },
            callback: (value) => {
              if (state.monthlyMetric === "tasks") {
                return value.toFixed(1).replace(".", ",") + " h";
              } else {
                return value;
              }
            }
          },
          grid: { display: false }
        },
        yAvg: {
          position: "right",
          offset: true,
          ticks: {
            color: "#a855f7",
            font: { size: 10 },
            callback: (value) => `${value.toFixed(0)} min`
          },
          grid: { display: false }
        }
      },
      plugins: {
        legend: {
          display: true,
          labels: { color: "#e5e7eb", font: { size: 11 } }
        },
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const label = ctx.dataset.label || "";
              const v = ctx.parsed.y;
              if (label === "Tarefas") {
                return `${label}: ${v}`;
              }
              if (label === "Horas") {
                return `${label}: ${v.toFixed(1).replace(".", ",")} h`;
              }
              if (label.startsWith("Tempo m√©dio")) {
                return `${label}: ${v.toFixed(0)} min`;
              }
              return `${label}: ${v}`;
            }
          }
        }
      }
    }
  });

  const monthlyCard = document.getElementById("monthlySubtitle")?.closest(".card");
  if (monthlyCard) {
    const titleEl = monthlyCard.querySelector(".card-title");
    const subEl   = monthlyCard.querySelector(".card-subtitle");
    if (titleEl && subEl) {
      titleEl.textContent = "Evolu√ß√£o mensal";
      subEl.textContent = "Volume de demandas ao longo dos meses filtrados.";
    }
  }

  // Clique na coluna ‚Üí abre modal com drill-down di√°rio
  canvas.onclick = function(evt) {
    if (!monthlyChart) return;
    const points = monthlyChart.getElementsAtEventForMode(
      evt,
      "nearest",
      { intersect: true },
      true
    );
    if (!points.length) return;
    const idx = points[0].index;
    const m = monthRows[idx];
    if (!m) return;
    openMonthlyDrilldown(m.year, m.monthIndex);
  };
}

/**********************************************************
 * GR√ÅFICO DESIGNERS
 **********************************************************/
function renderDesignerChart() {
  if (designerChart) {
    designerChart.destroy();
    designerChart = null;
  }

  const map = new Map();
  filteredData.forEach(d => {
    const user = d.user || "‚Äî";
    if (!map.has(user)) {
      map.set(user, { user, tasks: 0, minutes: 0 });
    }
    const agg = map.get(user);
    agg.tasks++;
    if (typeof d.durationMinutes === "number") {
      agg.minutes += d.durationMinutes;
    }
  });

  let rows = Array.from(map.values());
  rows.sort((a,b) => {
    const av = state.designerMetric === "tasks" ? a.tasks : a.minutes;
    const bv = state.designerMetric === "tasks" ? b.tasks : b.minutes;
    return bv - av;
  });
  rows = rows.slice(0, 10);

  const labels = rows.map(r => r.user);
  const dataValues = rows.map(r =>
    state.designerMetric === "tasks"
      ? r.tasks
      : (r.minutes / 60)
  );

  const ctx = document.getElementById("designerChart").getContext("2d");
  designerChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: state.designerMetric === "tasks" ? "Tarefas" : "Horas",
        data: dataValues
      }]
    },
    options: {
      indexAxis: "y",
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          ticks: {
            color: "#9ca3af",
            font: { size: 11 },
            callback: value => state.designerMetric === "tasks"
              ? value
              : value.toFixed(1).replace(".", ",")
          },
          grid: { color: "#1f2937" }
        },
        y: {
          ticks: { color: "#9ca3af", font: { size: 11 } },
          grid: { display: false }
        }
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: ctx => {
              const v = ctx.parsed.x;
              if (state.designerMetric === "tasks") {
                return `${v} tarefas`;
              } else {
                return `${v.toFixed(1).replace(".", ",")} h`;
              }
            }
          }
        }
      }
    }
  });
}

/**********************************************************
 * GR√ÅFICO PRODUTOS
 **********************************************************/
function renderBucketChart() {
  if (bucketChart) {
    bucketChart.destroy();
    bucketChart = null;
  }

  const map = new Map();
  filteredData.forEach(d => {
    const bucket = d.bucket || "‚Äî";
    if (!map.has(bucket)) {
      map.set(bucket, { bucket, tasks: 0, minutes: 0 });
    }
    const agg = map.get(bucket);
    agg.tasks++;
    if (typeof d.durationMinutes === "number") {
      agg.minutes += d.durationMinutes;
    }
  });

  let rows = Array.from(map.values());
  rows.sort((a,b) => {
    const av = state.bucketMetric === "tasks" ? a.tasks : a.minutes;
    const bv = state.bucketMetric === "tasks" ? b.tasks : b.minutes;
    return bv - av;
  });
  rows = rows.slice(0, 20);

  const labels = rows.map(r => r.bucket);
  const dataValues = rows.map(r =>
    state.bucketMetric === "tasks"
      ? r.tasks
      : (r.minutes / 60)
  );

  const ctx = document.getElementById("bucketChart").getContext("2d");
  bucketChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        label: state.bucketMetric === "tasks" ? "Tarefas" : "Horas",
        data: dataValues
      }]
    },
    options: {
      indexAxis: "y",
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          ticks: {
            color: "#9ca3af",
            font: { size: 11 },
            callback: value => state.bucketMetric === "tasks"
              ? value
              : value.toFixed(1).replace(".", ",")
          },
          grid: { color: "#1f2937" }
        },
        y: {
          ticks: { color: "#9ca3af", font: { size: 11 } },
          grid: { display: false }
        }
      },
      plugins: {
        legend: {
          display: false,
          labels: {
            color: "#e5e7eb",
            font: { size: 11 }
          }
        },
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const v = ctx.parsed.x;
              if (state.bucketMetric === "tasks") {
                return `${v} tarefas`;
              } else {
                return `${v.toFixed(1).replace(".", ",")} h`;
              }
            }
          }
        }
      }
    }
  });
}

/**********************************************************
 * RESUMO QUALITATIVO
 **********************************************************/
function renderQualitativeSummary() {
  const p = document.getElementById("qualitativeSummary");
  const ul = document.getElementById("qualitativeBullets");
  ul.innerHTML = "";

  if (!filteredData.length) {
    p.textContent =
      "Sem dados para o recorte atual. Ajuste os filtros para ver um resumo.";
    return;
  }

  const total = filteredData.length;
  const durations = filteredData
    .map(d => d.durationMinutes)
    .filter(v => typeof v === "number" && v > 0);
  const totalMin = durations.reduce((s, v) => s + v, 0);
  const avg = durations.length ? totalMin / durations.length : 0;
  const med = durations.length ? median(durations) : 0;

  // HE no per√≠odo (reusa l√≥gica dos KPIs)
  let totalHeMinutes = 0;
  const groups = new Map();
  filteredData.forEach(d => {
    if (!(d.dateObj instanceof Date)) return;
    const keyDate = d.dateObj.toISOString().slice(0, 10);
    const key = keyDate + "||" + (d.user || "");
    if (!groups.has(key)) {
      groups.set(key, { minutes: 0, user: d.user || "", date: d.dateObj });
    }
    const m = typeof d.durationMinutes === "number" ? d.durationMinutes : 0;
    groups.get(key).minutes += m;
  });
  groups.forEach(g => {
    const cap = getDailyCapMinutesForUser(g.user);
    const he = Math.max(0, g.minutes - cap);
    totalHeMinutes += he;
  });

  const highLoadBucket = (() => {
    const map = new Map();
    filteredData.forEach(d => {
      const b = d.bucket || "‚Äî";
      if (!map.has(b)) map.set(b, 0);
      map.set(b, map.get(b) + 1);
    });
    const arr = Array.from(map.entries());
    arr.sort((a, b) => b[1] - a[1]);
    return arr[0] || null;
  })();

  p.textContent =
    "Vis√£o r√°pida da carga de trabalho da equipe de design no recorte atual.";

  const li1 = document.createElement("li");
  li1.textContent =
    `Foram registradas ${total.toLocaleString("pt-BR")} tarefas, com tempo m√©dio de ${formatMinutesToHM(avg)} e mediano de ${formatMinutesToHM(med)}.`;
  ul.appendChild(li1);

  const li2 = document.createElement("li");
  li2.textContent =
    `No per√≠odo, o esfor√ßo total foi de ${formatMinutesToHM(totalMin)} de trabalho registrado.`;
  ul.appendChild(li2);

  if (totalHeMinutes > 0) {
    const liHe = document.createElement("li");
    liHe.textContent =
      `H√° aproximadamente ${formatMinutesToHM(totalHeMinutes)} acima do limite di√°rio previsto (horas extras), concentradas em alguns dias espec√≠ficos.`;
    ul.appendChild(liHe);
  }

  if (highLoadBucket) {
    const li3 = document.createElement("li");
    li3.textContent =
      `O produto com maior volume √© "${highLoadBucket[0]}", com ${highLoadBucket[1].toLocaleString("pt-BR")} tarefas.`;
    ul.appendChild(li3);
  }

  const segHigh = timeSegmentData["gt120"];
  if (segHigh && segHigh.count > 0) {
    const li4 = document.createElement("li");
    li4.textContent =
      `H√° ${segHigh.count.toLocaleString("pt-BR")} tarefas acima de 120 minutos ‚Äî vale investigar se s√£o casos especiais ou gargalos de fluxo.`;
    ul.appendChild(li4);
  }

  const segFast = timeSegmentData["lt20"];
  if (segFast && segFast.count > 0) {
    const li5 = document.createElement("li");
    li5.textContent =
      `${segFast.count.toLocaleString("pt-BR")} tarefas ficaram abaixo de 20 minutos; podem ser boas candidatas para automa√ß√µes ou templates recorrentes.`;
    ul.appendChild(li5);
  }

  const segNoTime = timeSegmentData["noTime"];
  if (segNoTime && segNoTime.count > 0) {
    const li6 = document.createElement("li");
    li6.textContent =
      `${segNoTime.count.toLocaleString("pt-BR")} tarefas est√£o sem dura√ß√£o registrada; pode valer revisar o processo de apontamento de horas.`;
    ul.appendChild(li6);
  }
}

/**********************************************************
 * MODAL ‚Äî Perfil de tempo (tabela completa + ordena√ß√£o)
 * (inclui WEEKDAY + MODO DE TRABALHO)
 **********************************************************/
function renderModalTasksTable(seg, tasks) {
  const container = document.getElementById("modalTableContainer");

  if (!tasks.length) {
    container.innerHTML =
      '<div class="empty-state">Nenhuma tarefa encontrada.</div>';
    return;
  }

  const sorted = [...tasks].sort((a, b) => {
    const dirMul = modalSortDir === "asc" ? 1 : -1;

    if (modalSortKey === "date") {
      const ad = a.dateObj ? a.dateObj.getTime() : 0;
      const bd = b.dateObj ? b.dateObj.getTime() : 0;
      if (ad === bd) return 0;
      return ad < bd ? -1 * dirMul : 1 * dirMul;
    }

  if (modalSortKey === "weekday") {
    const ad = a.dateObj ? a.dateObj.getDay() : -1; // 0=Dom ... 6=S√°b
    const bd = b.dateObj ? b.dateObj.getDay() : -1;
    if (ad === bd) return 0;
    return ad < bd ? -1 * dirMul : 1 * dirMul;
  }

    if (modalSortKey === "bucket") {
      const av = (a.bucket || "").toLowerCase();
      const bv = (b.bucket || "").toLowerCase();
      if (av === bv) return 0;
      return av < bv ? -1 * dirMul : 1 * dirMul;
    }

    if (modalSortKey === "designer") {
      const av = (a.user || "").toLowerCase();
      const bv = (b.user || "").toLowerCase();
      if (av === bv) return 0;
      return av < bv ? -1 * dirMul : 1 * dirMul;
    }

  // üîπ NOVO: ordenar por modo de trabalho (HO, FLEX, PRES)
  if (modalSortKey === "mode") {
    const order = { "HO": 0, "FLEX": 1, "PRES": 2, "OTHER": 3 };
    const am = (a.modeNorm || "").toUpperCase() || "OTHER";
    const bm = (b.modeNorm || "").toUpperCase() || "OTHER";
    const av = order[am] ?? 3;
    const bv = order[bm] ?? 3;
    if (av === bv) return 0;
    return av < bv ? -1 * dirMul : 1 * dirMul;
  }
    if (modalSortKey === "task") {
      const av = (a.task || "").toLowerCase();
      const bv = (b.task || "").toLowerCase();
      if (av === bv) return 0;
      return av < bv ? -1 * dirMul : 1 * dirMul;
    }

    if (modalSortKey === "duration") {
      const av =
        typeof a.durationMinutes === "number" ? a.durationMinutes : 0;
      const bv =
        typeof b.durationMinutes === "number" ? b.durationMinutes : 0;
      if (av === bv) return 0;
      return av < bv ? -1 * dirMul : 1 * dirMul;
    }

    return 0;
  });

  modalTasks = tasks;

let html = '<table><thead><tr>';
html += '<th data-sort-key="date">Data</th>';
html += '<th data-sort-key="weekday">Dia</th>';       // WEEKDAY (agora sort)
html += '<th data-sort-key="bucket">Produto</th>';
html += '<th data-sort-key="designer">Designer</th>';
html += '<th data-sort-key="mode">Modo</th>';         // MODO (agora sort)
html += '<th data-sort-key="task">Tarefa</th>';
html += '<th data-sort-key="duration">Dura√ß√£o</th>';
html += '</tr></thead><tbody>';

  sorted.forEach(d => {
    const wd = d.dateObj ? weekdayFromDate(d.dateObj) : "";
    const modeLabel = d.modeNorm || "";

    html += "<tr>";
    html += `<td>${d.dateObj ? formatShortDate(d.dateObj) : "‚Äî"}</td>`;
    html += `<td>${wd}</td>`;
    html += `<td>${d.bucket || "‚Äî"}</td>`;
    html += `<td>${d.user || "‚Äî"}</td>`;
    html += `<td>${modeLabel || "‚Äî"}</td>`;
    html += `<td>${d.task || ""}</td>`;
    html += `<td>${formatMinutesToHM(d.durationMinutes)}</td>`;
    html += "</tr>";
  });

  html += "</tbody></table>";

  container.innerHTML = html;

  const ths = container.querySelectorAll("th[data-sort-key]");
  ths.forEach(th => {
    th.style.cursor = "pointer";
    th.onclick = () => {
      const key = th.getAttribute("data-sort-key");
      if (modalSortKey === key) {
        modalSortDir = modalSortDir === "asc" ? "desc" : "asc";
      } else {
        modalSortKey = key;
        modalSortDir = key === "task" ? "asc" : "desc";
      }
      renderModalTasksTable(seg, modalTasks);
    };
  });
}

function openTimeSegmentModal(seg) {
  const entry = timeSegmentData[seg.id];
  const backdrop = document.getElementById("modalBackdrop");
  const title = document.getElementById("modalTitle");
  const subtitle = document.getElementById("modalSubtitle");

  title.textContent = "FAIXA DE TEMPO ‚Ä¢ " + seg.label;

  if (!entry || !entry.tasks.length) {
    subtitle.textContent =
      "Sem tarefas nesta faixa de dura√ß√£o para os filtros atuais.";
    renderModalTasksTable(seg, []);
    backdrop.classList.add("show");
    return;
  }

  modalSortKey = "date";
  modalSortDir = "desc";

  const totalMin = entry.totalMinutes || 0;
  subtitle.textContent =
    `Total de ${entry.count.toLocaleString("pt-BR")} tarefas nesta faixa, somando ${formatMinutesToHM(totalMin)}. Clique nos cabe√ßalhos para ordenar.`;

  renderModalTasksTable(seg, entry.tasks);
  backdrop.classList.add("show");
}

/**********************************************************
 * MODAL ‚Äî Drill-down mensal (gr√°fico di√°rio)
 **********************************************************/
function openMonthlyDrilldown(year, monthIndex) {
  const backdrop = document.getElementById("modalBackdrop");
  const title = document.getElementById("modalTitle");
  const subtitle = document.getElementById("modalSubtitle");
  const container = document.getElementById("modalTableContainer");

  const dailyMap = new Map();
  filteredData.forEach(d => {
    const dt = d.dateObj;
    if (!dt) return;
    if (dt.getFullYear() !== year || dt.getMonth() !== monthIndex) return;
    const day = dt.getDate();
    if (!dailyMap.has(day)) {
      dailyMap.set(day, { day, tasks: 0, minutes: 0 });
    }
    const agg = dailyMap.get(day);
    agg.tasks++;
    if (typeof d.durationMinutes === "number") {
      agg.minutes += d.durationMinutes;
    }
  });

  const rows = Array.from(dailyMap.values()).sort((a, b) => a.day - b.day);

  if (!rows.length) {
    title.textContent = "EVOLU√á√ÉO DI√ÅRIA";
    subtitle.textContent = "Sem dados para este m√™s no recorte atual.";
    container.innerHTML =
      '<div class="empty-state">Nenhuma tarefa encontrada.</div>';
    backdrop.classList.add("show");
    return;
  }

  const anyDate = new Date(year, monthIndex, 1);
  title.textContent = "EVOLU√á√ÉO NO M√äS";
  subtitle.textContent =
    `Distribui√ß√£o di√°ria em ${formatMonthFull(anyDate)} para os filtros atuais.`;

  container.innerHTML =
    '<div style="height:280px;"><canvas id="monthDrillCanvas"></canvas></div>';
  const ctx = document.getElementById("monthDrillCanvas").getContext("2d");

  if (monthDrillChart) {
    monthDrillChart.destroy();
    monthDrillChart = null;
  }

  const labels = rows.map(r => String(r.day).padStart(2, "0"));
  const tasksArr = rows.map(r => r.tasks);
  const hoursArr = rows.map(r => r.minutes / 60);
  const avgMinArr = rows.map(r =>
    r.tasks ? (r.minutes / r.tasks) : 0
  );

  const barData   = state.monthlyMetric === "tasks" ? tasksArr : hoursArr;
  const lineData  = state.monthlyMetric === "tasks" ? hoursArr : tasksArr;
  const barLabel  = state.monthlyMetric === "tasks" ? "Tarefas/dia" : "Horas/dia";
  const lineLabel = state.monthlyMetric === "tasks" ? "Horas/dia" : "Tarefas/dia";

  monthDrillChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          type: "bar",
          label: barLabel,
          data: barData,
          backgroundColor: "rgba(56,189,248,0.45)",
          borderRadius: 4,
          yAxisID: "yMain"
        },
        {
          type: "line",
          label: lineLabel,
          data: lineData,
          borderColor: "#f97373",
          backgroundColor: "rgba(248,113,113,0.25)",
          tension: 0.3,
          fill: false,
          pointRadius: 3,
          yAxisID: "yAux"
        },
        {
          type: "line",
          label: "Tempo m√©dio por tarefa (min)",
          data: avgMinArr,
          borderColor: "#a855f7",
          backgroundColor: "rgba(168,85,247,0.25)",
          tension: 0.3,
          fill: false,
          pointRadius: 2,
          borderDash: [4, 3],
          yAxisID: "yAvg"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          ticks: { color: "#9ca3af", font: { size: 11 } },
          grid: { display: false }
        },
        yMain: {
          position: "left",
          ticks: {
            color: "#9ca3af",
            font: { size: 11 },
            callback: (value) => {
              if (state.monthlyMetric === "tasks") {
                return value;
              } else {
                return value.toFixed(1).replace(".", ",") + " h";
              }
            }
          },
          grid: { color: "#1f2937" }
        },
        yAux: {
          position: "right",
          ticks: {
            color: "#6b7280",
            font: { size: 10 },
            callback: (value) => {
              if (state.monthlyMetric === "tasks") {
                return value.toFixed(1).replace(".", ",") + " h";
              } else {
                return value;
              }
            }
          },
          grid: { display: false }
        },
        yAvg: {
          position: "right",
          offset: true,
          ticks: {
            color: "#a855f7",
            font: { size: 10 },
            callback: (value) => `${value.toFixed(0)} min`
          },
          grid: { display: false }
        }
      },
      plugins: {
        legend: {
          display: true,
          labels: { color: "#e5e7eb", font: { size: 11 } }
        },
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const label = ctx.dataset.label || "";
              const v = ctx.parsed.y;
              if (label.includes("Tarefa")) {
                return `${label}: ${v}`;
              }
              if (label.includes("Hora")) {
                return `${label}: ${v.toFixed(1).replace(".", ",")} h`;
              }
              if (label.startsWith("Tempo m√©dio")) {
                return `${label}: ${v.toFixed(0)} min`;
              }
              return `${label}: ${v}`;
            }
          }
        }
      }
    }
  });

  backdrop.classList.add("show");
}

function closeModal() {
  const backdrop = document.getElementById("modalBackdrop");
  backdrop.classList.remove("show");
}

/**********************************************************
 * CARREGAR DADOS ‚Äì via fetch
 **********************************************************/
function loadData() {
  const info = document.getElementById("lastUpdateInfo");
  info.textContent = "Carregando dados da API‚Ä¶";
  console.log("[DASHBOARD] Iniciando fetch para API‚Ä¶", API_URL);

  fetch(API_URL + "?_ts=" + Date.now(), {
    method: "GET"
  })
    .then((resp) => {
      console.log("[DASHBOARD] Resposta HTTP:", resp.status);
      if (!resp.ok) {
        throw new Error("HTTP " + resp.status);
      }
      return resp.json();
    })
    .then((json) => {
      console.log("[DASHBOARD] JSON recebido:", json);
      handleDashboardData(json);
    })
    .catch((err) => {
      console.error("Erro ao carregar dados via fetch:", err);
      info.textContent = "Erro ao carregar dados da API.";
      rawData = [];
      filteredData = [];
      renderAll();
    });
}

/**********************************************************
 * Callback de tratamento dos dados
 **********************************************************/
function handleDashboardData(json) {
  const info = document.getElementById("lastUpdateInfo");

  try {
    if (!json || json.status !== "ok" || !Array.isArray(json.data)) {
      console.error("Resposta inesperada da API:", json);
      info.textContent = "Resposta inv√°lida da API.";
      rawData = [];
      filteredData = [];
      renderAll();
      return;
    }

    rawData = json.data
      .filter(item => item)
      .map(item => {
        let dateObj = null;
        if (item.date) {
          dateObj = parseDateSafe(item.date);
        }

        const duration =
          typeof item.durationMinutes === "number"
            ? Math.max(0, item.durationMinutes)
            : null;

        // tenta capturar o modo de trabalho de v√°rios jeitos: LOCAL_TR, mode, etc.
       // capturar modo de trabalho exatamente como vem do Apps Script
const rawMode =
  item.localTr ||    // <-- CORRETO (camelCase vindo do Apps Script)
  item.LOCAL_TR ||   // (fallback caso algum dia venha em upper)
  item.local_tr ||   // (fallback underscore)
  item.mode ||
  item.workMode ||
  "";

        const modeNorm = normalizeWorkMode(rawMode);

        return {
          rawDate: item.date || null,
          dateObj,
          bucket: item.bucket || "",
          task: item.task || "",
          user: item.user || "",
          startTime: item.startTime || null,
          endTime: item.endTime || null,
          durationMinutes: duration,
          modeRaw: rawMode,
          modeNorm,
          weekday: dateObj ? weekdayFromDate(dateObj) : ""
        };
      });

    console.log("[DASHBOARD] Registros recebidos:", rawData.length);

    if (!rawData.length) {
      info.textContent = "Sem dados retornados pela API.";
      filteredData = [];
      renderAll();
      return;
    }

    // Se for a primeira carga, define o per√≠odo padr√£o (rolling 12 meses)
    if (isFirstLoad) {
      applyDefaultPeriod();
      isFirstLoad = false;
    }

    // (re)monta filtros respeitando o state atual
    buildYearPills();
    buildMonthChips();
    buildBucketChips();
    buildDesignerChips();

    // pills de modo de trabalho
    buildWorkModePills();

    // aplica filtros usando o state atual (ano, m√™s, bucket, designer, busca, modo)
    applyFiltersAndRender();

    // texto "√∫ltima atualiza√ß√£o"
    const maxDateObj = rawData
      .map(d => d.dateObj)
      .filter(d => d instanceof Date && !isNaN(d.getTime()))
      .reduce((a, b) => (a && a > b ? a : b), null);

    if (maxDateObj) {
      info.textContent = "Dados atualizados at√© " + formatShortDate(maxDateObj);
    } else {
      info.textContent = "Dados carregados.";
    }
  } catch (err) {
    console.error("Erro ao tratar dados da API:", err);
    info.textContent = "Erro ao tratar dados da API.";
    rawData = [];
    filteredData = [];
    renderAll();
  }
}

/**********************************************************
 * EVENTOS DE UI
 **********************************************************/
function attachEvents() {
  const taskInput = document.getElementById("taskSearchInput");

  taskInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      state.taskSearch = taskInput.value;
      applyFiltersAndRender();
      registerTaskSearch(state.taskSearch, lastFilteredCount);
    }
  });

  taskInput.addEventListener("blur", () => {
    state.taskSearch = taskInput.value;
    applyFiltersAndRender();
  });

  document
    .getElementById("modalCloseButton")
    .addEventListener("click", closeModal);

  document
    .getElementById("modalBackdrop")
    .addEventListener("click", (e) => {
      if (e.target.id === "modalBackdrop") {
        closeModal();
      }
    });

  const monthlyToggle = document.getElementById("monthlyModeToggle");
  monthlyToggle.querySelectorAll("button").forEach(btn => {
    btn.addEventListener("click", () => {
      monthlyToggle
        .querySelectorAll("button")
        .forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      state.monthlyMetric = btn.dataset.mode;
      renderMonthlyChart();
    });
  });

  const bucketToggle = document.getElementById("bucketModeToggle");
  bucketToggle.querySelectorAll("button").forEach(btn => {
    btn.addEventListener("click", () => {
      bucketToggle
        .querySelectorAll("button")
        .forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      state.bucketMetric = btn.dataset.mode;
      renderBucketChart();
    });
  });

  const designerToggle = document.getElementById("designerModeToggle");
  designerToggle.querySelectorAll("button").forEach(btn => {
    btn.addEventListener("click", () => {
      designerToggle
        .querySelectorAll("button")
        .forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      state.designerMetric = btn.dataset.mode;
      renderDesignerChart();
    });
  });

  // Eventos dos toggles de modo de trabalho (FLEX / PRES / HO)
  document.addEventListener("click", (e) => {
    const btn = e.target.closest("#workModeRow .pill[data-mode]");
    if (!btn) return;

    const mode = btn.dataset.mode;
    // toggle visual
    btn.classList.toggle("active");

    // atualiza flags
    if (mode === "HO")   workModeView.showHO   = btn.classList.contains("active");
    if (mode === "PRES") workModeView.showPRES = btn.classList.contains("active");
    if (mode === "FLEX") workModeView.showFLEX = btn.classList.contains("active");

    applyFiltersAndRender();
  });

  console.log("[DASHBOARD] Eventos de UI anexados.");
}

/**********************************************************
 * INIT + AUTO REFRESH (5 MIN)
 **********************************************************/
document.addEventListener("DOMContentLoaded", () => {
  console.log("[DASHBOARD] DOMContentLoaded disparado.");
  attachEvents();
  loadData();
  setInterval(loadData, 5 * 60 * 1000);
});
</script>


</body>
</html>		